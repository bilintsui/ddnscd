#! /usr/bin/perl
# Version: 1.2-beta7
# Interval Version: 9
# Config Version: 3
use File::Basename;
use JSON;
use POSIX;
$|=1;
$pwd=$ENV{'PWD'};
$version_interval=9;
$version_config=3;
$version_major=1;
$version_minor=2;
$version_additional='(beta7)';
$version="$version_major.$version_minor$version_additional";
chomp($progname=basename($0));
$initmsg="Dynamic DNS Client Daemon v$version\n\nUsage:\n	$progname <-o|s|f [-p pidfile]> [-c conf]\n	$progname <-h|--help>\n\nSee more, watch: https://github.com/bilintsui/ddnscd\n(C) 2020 Bilin Tsui. Licensed with GNU GPL v3.";
$helpmsg="Dynamic DNS Client Daemon v$version\nArguments Help\n\nCommon:\n-h, --help	Show this message.\n-c, --conf	Optional, is your configuration file in JSON form.\n                Default /etc/ddnscd/config.json.\n\nRunmodes:\n-o, --once	Run ddnscd once.\n-s, --simple	Run ddnscd as a normal service.\n-f, --forking	Run ddnscd as a daemonized service.\n\nAdditional:\n-p, --pid	(Forking only) Optional, is your filename to save PID of main process to.\n                Default /run/ddnscd.pid.\n\nSee more, watch: https://github.com/bilintsui/ddnscd\n(C) 2020 Bilin Tsui. Licensed with GNU GPL v3.";

## Arguments Processing
{
$file_config='/etc/ddnscd/config.json';
$config_runmode_once=0;
$config_runmode_simple=0;
$config_runmode_forking=0;
$config_runmode='';
$config_additional_pid='/run/ddnscd.pid';
@arguments=@ARGV;
if(!@arguments)
{
	die("$initmsg\n");
}
do
{
	$rec_argu=shift @arguments;
	if($rec_argu=~/^-{1}\w+$/)
	{
		$rec_argu=~s/^-{1}//;
		if(($rec_argu=~/^[^cp]*[cp]$/)||($rec_argu=~/^[^cp]+$/))
		{
			$rec_argu_length=length($rec_argu);
			for($charcount=0;$charcount<$rec_argu_length;$charcount++)
			{
				$rec_subargu=substr($rec_argu,$charcount,1);
				if($rec_subargu eq 'h')
				{
					die("$helpmsg\n");
				}
				elsif($rec_subargu eq 'c')
				{
					$pre_file_config=shift @arguments;
					if($pre_file_config)
					{
						$file_config=$pre_file_config;
					}
					else
					{
						die("Error: You must be specify configuration file.\n")
					}
				}
				elsif($rec_subargu eq 'o')
				{
					$config_runmode_once=1;
				}
				elsif($rec_subargu eq 's')
				{
					$config_runmode_simple=1;
				}
				elsif($rec_subargu eq 'f')
				{
					$config_runmode_forking=1;
				}
				elsif($rec_subargu eq 'p')
				{
					$pre_config_additional_pid=shift @arguments;
					if($pre_config_additional_pid)
					{
						$config_additional_pid=$pre_config_additional_pid;
					}
					else
					{
						die("Error: You must be specify a pid file.\n")
					}
				}
				else
				{
					die("Syntax error: Unrecognized option \"-$rec_argu\".\n");
				}
			}
		}
		else
		{
			die("Syntax error: option \"c\" and \"p\" must be the last of the mixed options, or cannot mixed together.\n")
		}
	}
	if(($rec_argu=~/^-{2}\w+$/))
	{
		$rec_argu=~s/^-{2}//;
		if($rec_argu eq 'help')
		{
			die("$helpmsg\n");
		}
		elsif($rec_argu eq 'conf')
		{
			$pre_file_config=shift @arguments;
			if($pre_file_config)
			{
				$file_config=$pre_file_config;
			}
			else
			{
				die("Error: You must be specify a configuration file.\n")
			}
		}
		elsif($rec_argu eq 'once')
		{
			$config_runmode_once=1;
		}
		elsif($rec_argu eq 'simple')
		{
			$config_runmode_simple=1;
		}
		elsif($rec_argu eq 'forking')
		{
			$config_runmode_forking=1;
		}
		elsif($rec_argu eq 'pid')
		{
			$pre_config_additional_pid=shift @arguments;
			if($pre_config_additional_pid)
			{
				$config_additional_pid=$pre_config_additional_pid;
			}
			else
			{
				die("Error: You must be specify a pid file.\n")
			}
		}
		else
		{
			die("Syntax error: Unrecognized option \"--$rec_argu\".\n");
		}
	}
} while($#arguments>=0);
if(($config_runmode_once+$config_runmode_simple+$config_runmode_forking)!=1)
{
	die("Error: Cannot recognize which runmode which you want to use.\n")
}
if($config_runmode_once==1)
{
	$config_runmode='single';
}
if($config_runmode_simple==1)
{
	$config_runmode='simple';
}
if($config_runmode_forking==1)
{
	$config_runmode='forking';
}
}

## Pre Processing
{
if(!(-e $file_config))
{
	die ("Error: Configuration file \"$file_config\" don't exist.\n");
}
}

## Function Block 1
sub mkfork
{
	my($pidfile)=@_;
	if(-e $pidfile)
	{
		open OLDPID,"<$pidfile";
		chomp($oldpid=<OLDPID>);
		close OLDPID;
		if(-e "/proc/$oldpid/cmdline")
		{
			open OLDCOMM,"/proc/$oldpid/cmdline";
			chomp($oldcomm=<OLDCOMM>);
			close OLDCOMM;
			if($oldcomm=~/$progname/)
			{
				die("Error: A formerly process is still running. PID: $oldpid.\n");
			}
		}
	}
	if(!(-W dirname($pidfile)))
	{
		die("Error: Cannot write PID to ${pidfile}, permission denied.\n");
	}
	my($pid)=fork();
	if(!(defined($pid)))
	{
		die("Error: Forking failed.\n");
	}
	if($pid)
	{
		open PIDFD, ">$pidfile";
		print PIDFD $pid;
		close PIDFD;
		print "Started Dynamic DNS Client Daemon, PID: $pid.\n";
		exit(0);
	}
	setpgrp();
	setsid();
	chdir("/");
	umask(0);
	close STDERR;
	close STDOUT;
	close STDIN;
}
sub json_preprocess
{
	chomp(my(@source)=@_);
	my($result)='';
	foreach $recline(@source)
	{
		$recline=~s/^\s+//g;
		$recline=~s/\s+$//g;
		$result=$result.$recline;
	}
	return $result;
}
sub json_curl
{
	my($command)=@_;
	my($result)=();
	while(1)
	{
		my(@response)=();
		do
		{
			@response=readpipe($command);
		} while(!@response);
		my($processed)=json_preprocess(@response);
		eval { $result=decode_json($processed) };
		if(!$@)
		{
			last;
		}
	}
	return $result;
}
sub json_configload
{
	my($filename)=@_;
	open CONF,"<$filename";
	my(@config_preraw)=();
	chomp(@configs_preraw=<CONF>);
	close CONF;
	my($configs_raw)=json_preprocess(@configs_preraw);
	my($configs)=();
	eval { $configs=decode_json($configs_raw) };
	if($@)
	{
		die("Error: Malformed JSON in config file.\n");
	}
	return $configs;
}
sub cloudflare_zid_lookup
{
	my($username,$password,$update_rootdomain)=@_;
	my($return)='';
	my($decoded_json)=json_curl('curl -s -X GET "https://api.cloudflare.com/client/v4/zones" -H "Content-Type:application/json" -H "X-Auth-Key:'.$password.'" -H "X-Auth-Email:'.$username.'"');
	my($zones_success)=$decoded_json->{success};
	if(!$zones_success)
	{
		return -1;
	}
	my($zone_count)=($decoded_json->{result_info}->{count})-1;
	my($rec_zone_count)=0;
	for($rec_zone_count=0;$rec_zone_count<=$zone_count;$rec_zone_count++)
	{
		my($rec_zone_name)=$decoded_json->{result}->[$rec_zone_count]->{name};
		if($rec_zone_name eq $update_rootdomain)
		{
			my($rec_zone_id)=$decoded_json->{result}->[$rec_zone_count]->{id};
			$return=$rec_zone_id;
			last;
		}
	}
	return $return;
}
sub cloudflare_record_lookup
{
	my($username,$password,$update_domain,$zone_id)=@_;
	my($return)=();
	my($decoded_json)=json_curl('curl -s -X GET "https://api.cloudflare.com/client/v4/zones/'.$zone_id.'/dns_records?name='.$update_domain.'" -H "Content-Type:application/json" -H "X-Auth-Key:'.$password.'" -H "X-Auth-Email:'.$username.'"');
	my($records_success)=$decoded_json->{success};
	if(!$records_success)
	{
		return -1;
	}
	my($results)=$decoded_json->{result};
	foreach $rec_result(@{$results})
	{
		my($result_single)=();
		$result_single->{id}=$rec_result->{id};
		$result_single->{ip}=$rec_result->{content};
		$result_single->{type}=$rec_result->{type};
		push @{$return}, $result_single;
	}
	return $return;
}
sub cloudflare_dns_update
{
	my($username,$password,$zid,$rid,$type,$update_domain,$new_ip)=@_;
	my($execstr)='curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/'.$zid.'/dns_records/'.$rid.'" -H "Content-Type:application/json" -H "X-Auth-Key:'.$password.'" -H "X-Auth-Email:'.$username.'" --data \'{"type":"'.$type.'","name":"'.$update_domain.'","content":"'.$new_ip.'"}\'';
	my($decoded_json)=json_curl($execstr);
	my($response_success)=$decoded_json->{success};
	if(!$response_success)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

## Config Processing
{
$decoded_config=json_configload($file_config);
$config_version=$decoded_config->{confver};
$config_log_pre=$decoded_config->{log};
$config_log='';
$config_loglevel=$decoded_config->{loglevel};
$config_iplookup=$decoded_config->{lookup4};
$config_ip6lookup=$decoded_config->{lookup6};
$config_deploys=$decoded_config->{deploys};
if($config_version!=$version_config)
{
	die("Error: Incompatible configuation file, check your configuration version.\n");
}
if($config_log_pre=~/^\//)
{
	$config_log=$config_log_pre;
}
else
{
	$config_log=$pwd."/".$config_log_pre;
}
}

## Function Block 2 (Depended with Configuration Loaded)
sub ip_lookup
{
	my($type)=@_;
	if($type eq 'A')
	{
		my($address)=readpipe('curl -s '.$config_iplookup);
		if($address)
		{
			return $address;
		}
		else
		{
			return -1;
		}
	}
	elsif($type eq 'AAAA')
	{
		my($address)=readpipe('curl -s '.$config_ip6lookup);
		if($address)
		{
			return $address;
		}
		else
		{
			return -1;
		}
	}
	else
	{
		return -1;
	}
}
sub log_process
{
	my($level,$message)=@_;
	open LOGFD,">>$config_log";
	my($nowtime);
	chomp($nowtime=readpipe("date '+[%F %T %Z]'"));
	my($maxlevel)=$config_loglevel;
	if(!(defined($maxlevel)))
	{
		$maxlevel=1;
	}
	else
	{
		if(!($maxlevel=~/^\d+$/))
		{
			$maxlevel=1;
		}
		else
		{
			if(($maxlevel<0)||($maxlevel>2))
			{
				$maxlevel=1;
			}
		}
	}
	if($level<=$maxlevel)
	{
		print $message;
		print LOGFD "$nowtime $message";
	}
	close LOGFD;
}
sub cloudflare_apply
{
	my(@arguments)=@_;
	my($root)=shift @arguments;
	my($username)=shift @arguments;
	my($password)=shift @arguments;
	my(@deploy)=@arguments;
	$zid=cloudflare_zid_lookup($username,$password,$root);
	if($zid==-1)
	{
		log_process(0,"CF4_FINDZID(${root}): Not a vaild response, please check your account or it just a temporary failure.\n");
	}
	if($zid eq '')
	{
		log_process(0,"CF4_FINDZID(${root}): Cannot find ${root} zone associated with this accountant.\n");
	}
	foreach $recdeploy(@deploy)
	{
		my($realdomain)='';
		if(($recdeploy ne '@')&&($recdeploy ne ''))
		{
			$realdomain="${recdeploy}.${root}";
		}
		else
		{
			$realdomain="${root}";
		}
		my($records)=cloudflare_record_lookup($username,$password,$realdomain,$zid);
		if($records==-1)
		{
			log_process(0,"CF4_FINDREC(${realdomain}): Not a vaild response, please check your account or it just a temporary failure.\n");
		}
		if(!@{$records})
		{
			log_process(0,"CF4_FINDRID(${realdomain}): Cannot find any existing A/AAAA DNS record.\n");
		}
		foreach $rec_record(@{$records})
		{
			$rid=$rec_record->{id};
			$rtype=$rec_record->{type};
			$rip=$rec_record->{ip};
			$lip=-1;
			$failcount=0;
			while($lip==-1)
			{
				$lip=ip_lookup($rtype);
				if($failcount>=8)
				{
					last;
				}
				$failcount++;
			}
			if($failcount>=8)
			{
				log_process(0,"CF4_LOOKUP(${realdomain} - ${rtype}): Cannot lookup a vaild IP for current client, max tries reached.\n");
				next;
			}
			if($rip ne $lip)
			{
				my($response)=cloudflare_dns_update($username,$password,$zid,$rid,$rtype,$realdomain,$lip);
				if($response==0)
				{
					log_process(1,"CF4_UPDATE(${realdomain} - ${rtype}): Updated record from ${rip} to ${lip}.\n");
				}
				else
				{
					log_process(0,"CF4_UPDATE(${realdomain} - ${rtype}): Failed to update record.\n");
				}
			}
			else
			{
				log_process(2,"CF4_UPDATE(${realdomain} - ${rtype}): IP not changed, ignored.\n");
			}
		}
	}
}
sub cloudflare_run
{
	foreach $rec_deploys(@{$config_deploys})
	{
		my($config_root)=$rec_deploys->{root};
		my($config_username)=$rec_deploys->{username};
		my($config_password)=$rec_deploys->{password};
		my(@config_deploy)=@{$rec_deploys->{deploy}};
		cloudflare_apply($config_root,$config_username,$config_password,@config_deploy);
	}
}

## Main Process
{
if($config_runmode eq 'single')
{
	print "Started Dynamic DNS Client Daemon, just run once.\n";
	cloudflare_run;
}
else
{
	$config_daemon=$decoded_config->{tick};
	if($config_runmode eq 'forking')
	{
		mkfork($config_additional_pid);
	}
	if($config_runmode eq 'simple')
	{
		print "Started Dynamic DNS Client Daemon.\nUse Ctrl-C or send a signal to stop it.\n";
	}
	while(1)
	{
		cloudflare_run;
		sleep($config_daemon);
	}
}
}
